esphome:
  name: attic-heat-pump-remote
  friendly_name: attic heat pump remote
  includes:
    - debugger_method_vars.h



esp32:
  board: esp32dev
  framework:
    type: esp-idf


# Enable logging
logger:
  level: INFO
  baud_rate: 0
# Enable Home Assistant API
api:
  encryption:
# fill in with your key
    key: ""

ota:
  - platform: esphome
# copy from your generated esphome code
    password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password


  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
# enter your own info
    ssid: ""
    password: ""

captive_portal:

 


uart:
# change GPIO pins to what you want to use
  rx_pin: GPIO18
  tx_pin: GPIO19
  baud_rate: 4800
  debug:
    direction: RX
    dummy_receiver: true
    after:
      bytes: 32
    sequence:
      - lambda: |-
          static const char *const TAG = "uart_debug";
          uint8_t separator = ' ';
          std::string res;
          if (direction == UART_DIRECTION_RX) {
            res += "<<< ";
          } else {
            res += ">>> ";
          }
          size_t len = bytes.size();
          char buf[5];
          for (size_t i = 0; i < len; i++) {
            if (i > 0) {
              res += separator;
            }
            sprintf(buf, "%02X", bytes[i]);
            res += buf;
          }
          ESP_LOGD(TAG, "%s", res.c_str());
          delay(10);

          if (commandSent) {
            commandSent=false;
          } else if (newInput){
          } else {
            std::copy(bytes.begin(), bytes.end(), recData.begin());
            bool theyMatch = true;
            uint8_t i;
            for (i=0;i<6;++i)
            {
              if (i != 1) {
                if (recData[i]!=checkData[i])
                {
                  theyMatch = false;
                }
              }
            }
            if (theyMatch)
            {
              fanBytes = recData[REC_FAN];
              opBytes = recData[REC_MODE];
              setTemp = recData[REC_TEMP];
              ESP_LOGI("custom","Got these updated values: op %02X fan %02X temp %02X",opBytes,fanBytes,setTemp);
            } else 
            {
              ESP_LOGI("custom","First 6 bytes of incoming data were bad, not using values");
            }
          }

button:
  - platform: template
    name: "send button"
    id: "send_button"
    internal: true
    on_press: 
      - uart.write: !lambda |-
          sendData[SEND_MODE] = opBytes;
          sendData[SEND_FAN] = fanBytes;
          sendData[SEND_TEMP] = setTemp;
          ESP_LOGI("custom","Getting ready to send: op %02X fan %02X temp %02X",opBytes,fanBytes,setTemp);
          uint8_t i=0;
          uint32_t crc=0;
          int len=16;
          for(i=0;i<len;i++)
          { 
            if(i!=SEND_CRC)
            {
              crc+=sendData[i];
            }
          }
          ESP_LOGI("custom","sum of values for CRC calc is %i",crc);
          sendData[SEND_CRC] = 0xFF - (crc&0xFF);
          ESP_LOGI("custom","calculated CRC is %x",crc);
          return sendData;

  - platform: template
    name: "send follow me"
    id: "send_follow_me"
    internal: true
    on_press: 
      - uart.write: !lambda |-
          double followMeTemp = id(current_temperature).state;
          if (id(follow_me).state)
          {
            if (followMeInit) 
            {
              sendFollowMeData[10] = 0x42;
            } else 
            {
              
              sendFollowMeData[10] = 0x46;
              followMeInit = true;
            }
          } else 
          {
            if (followMeInit) 
            {
              sendFollowMeData[10] = 0x44;
              followMeInit = false;
            }
          }
          // The system will only accept celcius values for Follow Me
          if (followMeTemp < 50) 
          {
            sendFollowMeData[11] = static_cast<uint8_t>(std::round(followMeTemp));
          } else 
          {
            // convert to celcius
            sendFollowMeData[11] = static_cast<uint8_t>(std::round(((followMeTemp - 32.0) * 5.0 / 9.0)));
          }

          ESP_LOGI("custom","Sending follow me temp of %fC",followMeTemp);
          uint8_t i=0;
          uint32_t crc=0;
          int len=16;
          for(i=0;i<len;i++)
          { 
            if(i!=SEND_CRC)
            {
              crc+=sendFollowMeData[i];
            }
          }
          sendFollowMeData[SEND_CRC] = 0xFF - (crc&0xFF);
          return sendFollowMeData;


interval:

# check for updates by sending query string
  - interval: 5s
    startup_delay: 10s
    then:
      - if:
          condition:
            lambda: 'return newInput;'
          then:
           - delay: 1ms
          else:
            - uart.write: !lambda
                return queryData;

# if newInput is ready, send the command
  - interval: 3s
    startup_delay: 10s
    then:
      - if:
          condition:
            lambda: 'return newInput;'
          then:
           - lambda: |-
              if (newInput && !commandSent) {
                id(send_button).press();
                newInput = false;
                commandSent = true;
              }

 # Uncomment to send follow me temp every 60s
 # - interval: 30s
 #   startup_delay: 20s
 #   then:
 #     - lambda: |-
 #         if (!newInput && opBytes != 0x00 && !isnan(id(current_temperature).state)) {
 #           if (id(follow_me).state || followMeInit)
 #           {
 #             id(send_follow_me).press();
 #             commandSent = true;
 #           }
 #         }
          

sensor:
  # For follow me, set the entity_id to the sensor you want as your source temperature.
  - platform: homeassistant
    id: current_temperature
    entity_id: sensor.main_floor_current_temperature

  - platform: internal_temperature
    name: "Internal Temperature"
    state_class: measurement
    device_class: temperature
    unit_of_measurement: "°C"

  - platform: template
    name: "Inlet Air Temperature"
    unit_of_measurement: "°F"
    #unit_of_measurement: "°C"
    id: t1
    update_interval: 1s
    device_class: temperature
    state_class: measurement
    lambda: |-
      return recData[T1_INDEX];

  - platform: template
    name: "Current Setpoint"
    unit_of_measurement: "°F"
    #unit_of_measurement: "°C"
    id: tset
    update_interval: 1s
    device_class: temperature
    state_class: measurement
    lambda: |-
      return recData[REC_TEMP];
    


# this is the temperature of the refrigerant coming into the air handler from the compressor
# when it gets hot your compressor is heating, when it gets cold you are cooling.
# otherwise it should drift close to ambient or T1
  - platform: template
    name: "Coil A Temperature"
    unit_of_measurement: "°F"
    #unit_of_measurement: "°C"
    update_interval: 1s
    device_class: temperature
    state_class: measurement
    lambda: |-
      return recData[T2A_INDEX];

  - platform: template
    name: "Coil B Temperature"
    unit_of_measurement: "°F"
    #unit_of_measurement: "°C"
    update_interval: 1s
    device_class: temperature
    state_class: measurement
    lambda: |-
      return recData[T2B_INDEX];

# I don't think this is truly outside temperature. I think it's exhaust air temperature
# from the compressor outside which is ambient when it's not running.
  - platform: template
    name: "Outside Air Temperature"
    unit_of_measurement: "°F"
    #unit_of_measurement: "°C"
    update_interval: 1s
    device_class: temperature
    state_class: measurement
    lambda: |-
      return recData[T3_INDEX];

# the 2 error code registers combined in one message. it's just the code number,
# you will need the service manual to decode them probably. I haven't tested any error
# codes yet. 
text_sensor:
  - platform: template
    name: "Error Codes"
    update_interval: 1s
    lambda: |-
      return {"E1: " + std::to_string(recData[23]) + " E2: " + std::to_string(recData[24])};


  - platform: template
    name: "Fan Bytes"
    update_interval: 1s
    lambda: |-
      std::ostringstream oss;
      oss << std::uppercase << std::hex << std::setfill('0');
      oss << "0x";
      oss << std::setw(2) << static_cast<int>(fanBytes);
      return {oss.str()};

  - platform: template
    name: "Operating Mode Bytes"
    update_interval: 1s
    lambda: |-
      std::ostringstream oss;
      oss << std::uppercase << std::hex << std::setfill('0');
      oss << "0x";
      oss << std::setw(2) << static_cast<int>(opBytes);
      return {oss.str()};

  - platform: template
    name: "Operating Mode Text"
    update_interval: 1s
    lambda: |-
      switch (opBytes)
      {
        case 0x00:
          op = "off";
          break;
        case 0x91:
          // this is the flag for heating while in auto
          op = "auto (heating)";
          break;
        case 0x98:
          // this is the flag for cooling in auto mode
          op = "auto (cooling)";
          break;
        case 0x10:
          // this is the flag for startup in auto mode
          op = "auto (startup)";
          break;
        case 0x94:
          // this is the flag for idle in auto mode
          op = "auto (idle)";
          break;
        case 0x88:
          op = "cool";
          break;
        case 0x82:
          op = "dry";
          break;
        case 0x84:
          op = "heat";
          break;
        case 0x81:
          op = "fan_only";
          break;
        default:
          op = "off";
      }
      return op;

  - platform: template
    name: "Fan Mode Text"
    update_interval: 1s
    lambda: |-
      switch (fanBytes)
      {
        case 0x80:
          fan = "auto";
          break;
        case 0x81:
          fan = "auto (high)";
          break;
        case 0x82:
          fan = "auto (medium)";
          break;
        case 0x84:
          fan = "auto (low)";
          break;
        case 0x01:
          fan = "high";
          break;
        case 0x02:
          fan = "medium";
          break;
        case 0x04:
          fan = "low";
          break;
        default:
          fan = "auto";
      }
      return fan;

  - platform: template
    name: "Unk Bytes"
    update_interval: 1s
    lambda: |-
      std::ostringstream oss;
      oss << std::uppercase << std::hex << std::setfill('0');
      oss << "0x";
      oss << std::setw(2) << static_cast<int>(19);
      return {oss.str()};

# the last message received from the air handler. sorry it is in decimal :(
  - platform: template
    name: "Full data string"
    update_interval: 15s
    lambda: |-
      std::ostringstream oss;
      oss << std::uppercase << std::hex << std::setfill('0');
      uint8_t i;
      for (i=0;i<(sizeof(recData) / sizeof(recData[0]));i++)
      {
        if (i>0)
        {
          oss << ' ';
        }
        oss << "0x";
        oss << std::setw(2) << static_cast<int>(recData[i]);
      }
      return {oss.str()};
      

select:
  - platform: template
    name: "Fan Mode"
    id: fanMode
    update_interval: 1s
    options:
      - 'low'
      - 'medium'
      - 'high'
      - 'auto'
      
    lambda: |-
      switch (fanBytes)
      {
        case 0x80:
          fan = "auto";
          break;
        case 0x01:
          fan = "high";
          break;
        case 0x02:
          fan = "medium";
          break;
        case 0x04:
          fan = "low";
          break;
        default:
          fan = "auto";
      }
      return fan;
    set_action: 
      - lambda: |-
          if (fan != x)
          {
            fan = x;
            ESP_LOGI("custom","change fan to: %x",x);
            if (fan == "high"){
              fanBytes = 0x01;
            } else if (fan == "auto"){
              fanBytes = 0x80;
            } else if (fan == "medium"){
              fanBytes = 0x02;
            } else if (fan == "low"){
              fanBytes = 0x04;
            } else {
              fanBytes = 0x80;
              ESP_LOGI("custom","Defaulting to auto, invalid fan input: %s",x);
            }
            ESP_LOGI("custom","selected %x",fanBytes);
            newInput = true;
          }


  - platform: template
    id: opMode
    name: "Operating Mode"
    update_interval: 1s
    options:
      - 'off'
      - 'auto'
      - 'cool'
      - 'dry'
      - 'heat'
      - 'fan_only'
      # need to add switch case for updating the value based off opBytes
    lambda: |-
      switch (opBytes)
      {
        case 0x00:
          op = "off";
          break;
        case 0x91:
          // this is the flag for heating while in auto
          op = "auto";
          break;
        case 0x98:
          // this is the flag for cooling in auto mode
          op = "auto";
          break;
        case 0x10:
        case 0x94:
          // this is the flag for idle in auto mode
          op = "auto";
          break;
        case 0x88:
          op = "cool";
          break;
        case 0x82:
          op = "dry";
          break;
        case 0x84:
          op = "heat";
          break;
        case 0x81:
          op = "fan_only";
          break;
        default:
          op = "off";
      }
      return op;
    set_action:
      - lambda: |-
          if (op != x)
          {
            followMeInit = false;
            op = x;
            if (op == "off"){
              opBytes = 0x00;
            } else if (op == "auto"){
              opBytes = 0x90;
            } else if (op == "cool"){
              opBytes = 0x88;
            } else if (op == "dry"){
              opBytes = 0x82;
            } else if (op == "heat"){
              opBytes = 0x84;
            } else if (op == "fan_only"){
              opBytes = 0x81;
            } else {
              opBytes = 0x00;
              ESP_LOGI("custom","Defaulting to off, invalid mode input: %s",x);
            }
            ESP_LOGI("custom","selected %x for mode",opBytes);
            newInput = true;
          }

switch:
  - platform: template
    name: "Follow Me"
    id: follow_me
    optimistic: true
    turn_on_action:
      - logger.log: "Follow Me was turned ON"
    turn_off_action:
      - logger.log: "Follow Me was turned OFF"

number:
  - platform: template
    name: "Set Point"
    id: setPoint
    step: 1
    mode: box
    min_value: 0
    max_value: 100
    unit_of_measurement: "°F"
    #unit_of_measurement: "°C"
    device_class: temperature
    update_interval: 1s
    lambda: |-
      return static_cast<int>(setTemp);
    set_action:
      - lambda: |-
          if (setTemp != x)
          {
            setTemp = static_cast<uint8_t>(x);
            ESP_LOGI("custom","new temperature of %x", setTemp);
            ESP_LOGI("custom","static cast result is %i", static_cast<int>(setTemp));
            newInput = true;
          }
            

